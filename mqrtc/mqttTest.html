<!doctype html>
<meta charset="utf-8">
<head>
    <title>Testing WebRTC</title>
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.1/jquery.min.js"></script>    
    <script src="http://cdnjs.cloudflare.com/ajax/libs/flot/0.8.3/jquery.flot.js"></script>    
</head>

<html>
<body>

<h4>Connect to TR4 Device</h4>
<button id="createRTCDataChannelBtn">Create RTCDataChannel, send offer to remote over mqtt</button>
<hr>
<a id="myModalLabel">Your RTC offer to remote : </a>
<input id="localOffer" rows=10 cols=200>
<br>
<a>The RTC answer form remote : </a>
<input id="remoteAnswer" rows=10>
<!-- <input id="remoteAnswer" rows=10 cols=50> -->
<br>
<br>
<button id="connectRtcBtn">Establish RTCPeerConnection.</button>
<button id="disconnectRtcBtn">Disconnect RTCPeerConnection.</button>
<hr>
<button id="sendCmdConnectBtn" onclick="sendCmd_connect()">Send Cmd Connect</button>
<button id="sendCmdDisconnectBtn" onclick="sendCmd_disconnect()">Send Cmd Disconnect</button>
<button id="sendCmd9eBtn" onclick="sendCmd_9e()">Send Cmd 9e</button>

<hr>
Log:
<br>
<div id="chatlog" style="height:200px; overflow:auto; border:1px solid"></div>
<br>
<!--
<input type="text" id="messageTextBox" placeholder="Type your message here">
<button id="sendMessageBtn" onclick="sendMessage()">Send message</button>
-->
<h3>TR4 Plot</h3>
<div id="holder" style="width:400px;height:350px"></div>


<script src="../node_modules/buffer/dist/buffer.js"></script>
<script src="../node_modules/mqtt/dist/mqtt.js"></script>
<script src="../rb2/rb2_util.js"></script>
<script src="../proc01ify.js"></script>

<script>
//var Buffer;
var pit = new Pit();

var proc01 = new Proc01();
var b = new Buffer([0,1,2,3,4]);
/*
Pit_Load = function()
{
}

Pit_Process = function(rData)
{
}
Pit_Save = function()
{
}
*/
let P = {}; //BOGUS



var mqttParam_1 = {
    //mqttServer : 'mqtt://ocn.cloudns.org',
    mqttServer : 'ws://ocn.cloudns.org:1884',
    topic_sendAnswer: 'sendAnswer',
    topic_makeOffer:  'makeOffer'
};

/*
var client = mqtt.connect(mqttParam_1.mqttServer)
  
client.subscribe("mqtt/demo")

client.on("message", function (topic, payload) {
    alert([topic, payload].join(": "))
    client.end()
})
client.publish("mqtt/demo", "hello world!")
*/

var mqtt_client = mqtt.connect( mqttParam_1.mqttServer )
//var that = this;
mqtt_client.subscribe(mqttParam_1.topic_sendAnswer, (err, granted) => {
    if(err)
        console.log('mqtt_client.subscribe(sendAnswer) FAILED')
    else {
        console.log('mqtt_client.subscribe(sendAnswer) OK')
        //that.ready = true;
    }
})

mqtt_client.on('message',
    function(topic, answer) {
        //that.emit('gotAnswer', JSON.parse(answer) );
        remoteAnswer.value = answer;
        //document.getElementById('connectRtcBtn').disabled = false;
        //alert([topic, answer].join(": "))
    }
);

/*
this.sendOffer = function(offer) { // PUBLIC
    mqtt_client.publish(mqttParam_1.topic_makeOffer, JSON.stringify(offer));
}
*/


localOffer.value = remoteAnswer.value  = "";
//remoteOffer.value = localAnswer.value = "";

// BOB: create
createRTCDataChannelBtn.onclick = function() {
    //document.getElementById('connectRtcBtn').disabled = true;
    dc1 = pc.createDataChannel('test', {reliable: true})
    activedc = dc1
    
    dc1.onopen = function(e) {
        console.log("\nConnected!");
        //document.getElementById('connectRtcBtn').disabled = true;
        document.getElementById('connectRtcBtn').innerHTML = 'Connected!';
        //callbackForConnected();
        //mqtt_client.end();
        //that.inputLoop(this.channel);
    };

    dc1.onmessage = function(e) {
        if (e.data.size) {
            fileReceiver1.receive(e.data, {})
        } else {
            if (e.data.charCodeAt(0) == 2) {
                return
            }
            var data = JSON.parse(e.data)
            if (data.type === 'file') {
                fileReceiver1.receive(e.data, {})
            } else {
                display(data.message.cmd);
                processUp(data.message);
            }
        }
    }

    pc.createOffer( 
        function(desc) { pc.setLocalDescription(desc, function() {}, function() {})  },
        function() { },
        sdpConstraints
    );
};

// BOB: pasted Alice's answer
connectRtcBtn.onclick = function () {
    var answer = remoteAnswer.value;
    var answerDesc = new RTCSessionDescription(JSON.parse(answer))
    console.log('set RemoteDescription --> open a connection?!?') // -> Connected!
    pc.setRemoteDescription(answerDesc);
};
disconnectRtcBtn.onclick = function () {
    console.log('todo Disconnect');
    pc.close();
};


// ALICE: pasted Bob's answer
/*
offerRecdBtn.onclick = function() {
  var offer = remoteOffer.value;
  var offerDesc = new RTCSessionDescription(JSON.parse(offer))
  pc2.setRemoteDescription(offerDesc)
  pc2.createAnswer(function(answerDesc) {
    pc2.setLocalDescription(answerDesc)
  },
  function () { },
  sdpConstraints)
};
*/

if (navigator.webkitGetUserMedia) {
  RTCPeerConnection = webkitRTCPeerConnection
}

//var cfg = {'iceServers': [{'url': "stun:stun.gmx.net"}]};
var cfg = { 
        iceServers: [
            {
                urls : 'turn:ocn.cloudns.org:3478',
                username:'karel',
                credential:'abc123'
                //urls: "stun:stun.services.mozilla.com",
                //username: "louis@mozilla.com", 
                //credential: "webrtcdemo"
            }//,{
            //  urls: 'stun:ocn.cloudns.org:3478'
            //}
        ]
    };
var con = { 'optional': [{'DtlsSrtpKeyAgreement': true}] };

var pc = new RTCPeerConnection(cfg, con),
    dc1 = null, tn1 = null, activedc, pc1icedone = false;

var sdpConstraints = {
  optional: [],
}

pc.onicecandidate = function (e) { // <- pc.createOffer  will cause this to 'fire'
    //console.log('pc.onicecandidate: e =', e);
    if (e.candidate == null) {
        localOffer.value = JSON.stringify(pc.localDescription); // Display localoffer on HTML screeen
        mqtt_client.publish(mqttParam_1.topic_makeOffer, JSON.stringify(pc.localDescription));
    }
}

pc.oniceconnectionstatechange = function() {
    console.log('oniceconnectionstatechange: pc.iceConnectionState =', pc.iceConnectionState);
    switch (pc.iceConnectionState) {
      case 'failed':
        console.log('oniceconnectionstatechange: failed ');
        //util.log('iceConnectionState is disconnected, closing connections to ' + peerId);
        //connection.emit('error', new Error('Negotiation of connection to ' + peerId + ' failed.'));
        //connection.close();
        break;
      case 'disconnected':
        console.log('oniceconnectionstatechange: disconnected ');
        //util.log('iceConnectionState is disconnected, closing connections to ' + peerId);
        //connection.close();
        break;
      case 'completed':
        console.log('oniceconnectionstatechange: completed ');
        //pc.onicecandidate = util.noop;
        break;
    }
};

/*
function sendMessage () {
  if (messageTextBox.value) {
    activedc.send(JSON.stringify({message: messageTextBox.value}));
    chatlog.innerHTML += '[' + new Date() + '] ' + messageTextBox.value + '</p>';
    messageTextBox.value = "";
  }
  return false
}
*/

var ble_id = 'd81e6c802446';
//var CONNECT_REM          = 'connect:rem';           // Down
//var DISCONNECT_REM       = 'disconnect:rem';        // Down
function display( text )
{
    //chatlog.innerHTML += '[' + new Date() + '] ' + text + '</p>';
    chatlog.innerHTML += '[...] ' + text + '</p>';
    chatlog.scrollTop = chatlog.scrollHeight
}

function sendCmd_connect () {
    var _cmd = CONNECT_REM;
    var _payload = { id: ble_id };
    var dataOut = { cmd: _cmd, payload : _payload};
    //this.channel.send(JSON.stringify({message: dataOut}));
    activedc.send(JSON.stringify({message: dataOut}));
    display('Connecting')

    return false
}
function sendCmd_disconnect () {
    var _cmd = DISCONNECT_REM;
    var _payload = { id: ble_id };
    var dataOut = { cmd: _cmd, payload : _payload};

    //this.channel.send(JSON.stringify({message: dataOut}));
    activedc.send(JSON.stringify({message: dataOut}));
    
    display('Disconnecting')

    return false
}

function sendCmd_9e () {
    //var pkt = new Buffer( [0x01, 0x9e,0x00, 0x00,0x00 ,0xce,0x94] );
    //var pkt = new Uint8Array( [0x01, 0x9e,0x00, 0x00,0x00 ,0xce,0x94] );
    var pkt = { type: 'Buffer',
     data: [ 0x01, 0x9e,0x00, 0x00,0x00 ,0xce,0x94 ] }

    var _cmd = DNPKT_REM;
    var _payload = { id: ble_id, pkt: pkt};
    var dataOut = { cmd: _cmd, payload : _payload };

    //this.channel.send(JSON.stringify({message: dataOut}));
    activedc.send(JSON.stringify({message: dataOut}));
    display('Sent 9e command');
    return false
}


function processUp(dataIn)
{
    //display('processUp');
    
    //console.log('[O ] got dataIn from crtc ...')   
    //console.log('[O ] got dataIn from crtc = ', dataIn )   
    cmd = dataIn.cmd;
    switch( dataIn.cmd)
    {
        //---------------------------------------------------------------------
        case SCANSTARTED_REM:
            console.log('Scan Started dataIn =', dataIn);
            break;
        case SCANSTOPPED_REM:
            console.log('Scan Stopped dataIn =', dataIn);
            break;

        case SCANDATA_REM:
            //console.log('Scan Data : id = ', dataIn.payload.id );
            //console.log('Scan Data : ', dataIn.payload );
            break;

        //---------------------------------------------------------------------
        case CONNECTIONSTATUS_REM:
            var _id = dataIn.payload.id;
            var _status = dataIn.payload.status;
            //console.log('Connection Status : id = ', _id, 'status = ', _status );
            if(_status == true) {
                dl.OnTR4_Connected( _id )
            }
            if(_status == false) {
                dl.OnTR4_Disconnected( _id )
            }
            break;

        //---------------------------------------------------------------------
        case DNPKTSENTCFM_REM:
            var _id = dataIn.payload.id;
            //console.log('Packet Sent : id = ', _id );
            break;

        case UPPKT_REM:
            var _id = dataIn.payload.id;
            var _pkt = dataIn.payload.pkt;

            //TODO dataIn.payload.pkt = Buffer.from(dataIn.payload.pkt.data);

            dataIn.payload.pkt = dataIn.payload.pkt.data;

            //console.log('Packet received : id = ', _id, 'pkt = ', _pkt );
            dl.OnTR4_upPacket( true, dataIn.payload )
            break;

    }

}



var DL = function()
{
    //this.adapter = BleAdapter;
    //this.tr4 = null;
    this.id = 42;
}

DL.prototype.SendTr4Packet = function( pkt )
{
    var _cmd = DNPKT_REM;
    var _payload = { id: this.id, pkt: pkt};
    //var dataOut = { cmd: _cmd, payload : _payload};
    var dataOut = { cmd: _cmd, payload : _payload };
    //console.log('---------------------------------------------------------------')
    //console.log('DL.prototype.SendTr4Packet _payload = ', _payload)
    //console.log('DL.prototype.SendTr4Packet  dataOut = ', dataOut)
    //console.log('---------------------------------------------------------------')

    //ortc.sendData( dataOut );
    activedc.send(JSON.stringify({message: dataOut}));

    //this.tr4.SendPacket( pkt, (error) => {
    //});
}

DL.prototype.OnTR4_Connected = function( id )
{
    //console.log('OnTR4_Connected')
    dl.processCmd('proc_Send0x9e', id )
}
DL.prototype.OnTR4_Disconnected = function( id )
{
    //console.log('OnTR4_Disconnected')
}
DL.prototype.OnTR4_upPacket = function( status, id_pkt )
{
    //console.log('OnTR4_upPacket')
    dl.processCmd('proc_OnUpPkt', id_pkt )
}


DL.prototype.Tr4Disconnect = function()
{
    var _cmd = DISCONNECT_REM;
    var _payload = { id: this.id };
    var dataOut = { cmd: _cmd, payload : _payload};
    //dataOut = JSON.stringify( dataOut)
    //ortc.sendData( dataOut );
    activedc.send(JSON.stringify({message: dataOut}));

}

DL.prototype.Start = function(id, callback)
{
    this.id = id;

    var _cmd = CONNECT_REM;
    var _payload = { id: this.id };
    var dataOut = { cmd: _cmd, payload : _payload};
    //dataOut = JSON.stringify( dataOut)
    //ortc.sendData( dataOut );
    activedc.send(JSON.stringify({message: dataOut}));

    /*
    this.adapter.ScanForDevice(id, (error, device) => {
        if(error){
            console.log('Error during ScanForDevice: ', error)
            callback(error);
            return;
        }
        console.log('###########  param id = ', id )
        console.log('########### device.id = ', device.id )
        this.tr4 = new TdTR4(device, id);

        this.tr4.on('tr4:connected', this.OnTR4_Connected )       // this.tr4.on('tr4:connected', this.OnTR4_Connected.bind(this) )
        this.tr4.on('tr4:disconnected', this.OnTR4_Disconnected ) // this.tr4.on('tr4:disconnected', this.OnTR4_Disconnected.bind(this) )
        this.tr4.on('tr4:upPacket', this.OnTR4_upPacket )         // this.tr4.on('tr4:upPacket', this.OnTR4_upPacket.bind(this) )
        
        this.tr4.connect( (error) => {
            //console.log('tr4.connect callback()')
            if(error)
                callback(error);
            else
                callback(null, 'Connected');
        });
    })
    */

}

let E_data = '';
DL.prototype.processCmd = function( procId, data )
{

    switch(procId){
        case 'proc_Start':
            this.TT_0 = Date.now();
            this.Start(data.id, (error, param) => {
                if(!error)
                {
                    // TODO Start Sending data
                }
            });
            break;

        case 'proc_Send0x9e':
            this.TT_1 = Date.now();
            //var pkt = new Buffer( [0x01, 0x9e,0x00, 0x00,0x00 ,0xce,0x94] );
            var pkt = { type: 'Buffer', data: [ 0x01, 0x9e,0x00, 0x00,0x00 ,0xce,0x94 ] }

            this.SendTr4Packet( pkt );            
            break;
        
        case 'proc_OnUpPkt':
            this.TT_3 = Date.now();
            var id = data.id;
            var pkt = data.pkt;
            //console.log('proc_OnUpPkt: pkt[0]=', pkt[0], ', pkt[1]=', pkt[1]);
            if( pkt[1] == 0x9e)
            {
                pit.P.TS_current = Math.round(Date.now()/1000); // To match pit.P.ch1Raw 
                //proc01.dump_9e(pkt);
                //BOGUS?
                const buf = Buffer.from(pkt);
                //const buf = pkt.data; //bogus
                pit.P.security  = buf.readUInt32LE(5 + 0); //    [00]BLE Security Code = 26243047
                pit.P.devName   = buf.toString('utf8', 5 + 4, 5 + 4 + 16); //[04]Name              = "TR41_582C0206振 "
                console.log('devName = ' + pit.P.devName);
                pit.P.grpName   = buf.toString('utf8', 5 + 4 + 16, 5 + 4 + 16 + 10); //[20]Group             = "           "
                pit.P.serial    = buf.readUInt32LE(5 + 32); // 582c0206
                pit.P.ch1Raw    = buf.readUInt16LE(5 + 38); //[38] Ch1 Raw          = 1253
                pit.P.ch2Raw    = buf.readUInt16LE(5 + 40); //[40] Ch2 Raw          = 61166
                pit.P.battLevel = buf.readUInt8   (5 + 42);

                var sData = proc01.getPkt_69(); // Use this to get the interval
                var sPkt = proc01.makePkt_9f(sData, 0x26243047);

                //BOGUS
                var Bpkt = Buffer.from(sPkt);
                //const Bpkt = { type:'Buffer', data : sPkt }; //bogus
                this.SendTr4Packet( Bpkt );
            }
            else
            if( pkt[1] == 0x9f )
            {
                var rData = proc01.fromPkt_9f(pkt);
                //proc01.dumpHex(rData);
                
                if( rData[1] == 0x69)
                {
                    //BOGUS
                    const buf = Buffer.from(rData);
                    //const buf = rData.data; //bogus
                    pit.P.interval    = buf.readUInt16LE(5 + 0);  // [00]record_int    = 10
                    //proc01.dump_69(rData);
                    
                    // We now know the interval, so we can estimate the No of samples we need to download
                    pit.P.nSamples = 512; //TODO FUDGE
                    /* TODO
                    if( pit.P.TS_history == 0){
                        pit.P.nSamples = 512;
                    } else {
                        pit.P.TS_0 = Date.now();
                        pit.P.TS_0 = Math.round(pit.P.TS_0/1000);   // The time right now. Round to seconds
                        var delta = pit.P.TS_0 - pit.P.TS_history;
                        pit.P.nSamples = Math.floor(delta/pit.P.interval);
                        pit.P.nSamples += 5; // some extras won't hurt
                        if(pit.P.nSamples > 512)
                            pit.P.nSamples = 512;
                    }
                    */
                    /*
                    console.log('pit.P.nSamples    = ', pit.P.nSamples );
                    console.log('======================================================================');
                    console.log('P  = ', P );
                    */

                    var sData = proc01.getPkt_48('bytes', pit.P.nSamples * 2);
                    var sPkt = proc01.makePkt_9f(sData, 0x26243047);
                    pit.P.TS_0 = Date.now();

                    var Bpkt = Buffer.from(sPkt);
                    this.SendTr4Packet( Bpkt );
                }
                else
                if( rData[1] == 0x48)
                {
                    pit.P.TS_1 = Date.now();
                    //console.log('Delta TS = ', pit.P.TS_1 - pit.P.TS_0)

                    const buf = Buffer.from(rData);
                    //pit.P.interval    = buf.readUInt16LE(5 + 0);  // [00]record_int    = 10
                    pit.P.rsvTime     = buf.readUInt32LE(5 + 12); // [12]rsv_time      = 9
                    pit.P.lastDataNo  = buf.readUInt32LE(5 + 26); // [26]last_data_no  = 181
                    pit.P.dataSize    = buf.readUInt16LE(5 + 30); // [30]data_size     = 64
                    pit.P.allDataSize = buf.readUInt16LE(5 + 32); // [32]all_data_size = 362
                    pit.P.endDataSize = buf.readUInt16LE(5 + 34); // [34]end_data_size = 181
                    // Show 48 result
                    //proc01.dump_48(rData);

                    pit.P.TS_now = Math.floor(pit.P.TS_0/1000); //pit.P.TS_1
                    pit.P.TS_last = pit.P.TS_now - pit.P.rsvTime;
                    pit.P.TS_recStart =  pit.P.TS_last - (pit.P.nSamples * pit.P.interval);
                    /*
                    console.log('pit.P.TS_now      = ', pit.P.TS_now );
                    console.log('pit.P.rsvTime     = ', pit.P.rsvTime );
                    console.log('pit.P.TS_last     = ', pit.P.TS_last );
                    console.log('pit.P.nSamples    = ', pit.P.nSamples );
                    console.log('pit.P.TS_recStart = ', pit.P.TS_recStart );
                    */
                    //console.log('Should be an integer = ', (pit.P.TS_recStart - pit.P.TS_history)/pit.P.interval );

                    pit.P.TS_history = pit.P.TS_last; // to be saved
            
                    // Send 41 pkt
                    var sData = proc01.getPkt_41(0);
                    var sPkt = proc01.makePkt_9f(sData, 0x26243047);
                    //proc01.dumpHex(sPkt);

                    var Bpkt = Buffer.from(sPkt);
                    this.SendTr4Packet( Bpkt );
                }
                else
                {
                    //proc01.dump_41(rData);
                    pit.Pit_Process(rData);
                    //TODO pit.Pit_Save(); - can't get access to local file system from browser
                    
                    var _buf = Buffer.from(rData);
                    var _len = (_buf[4]<<8) + _buf[3];
                    var count = _len >> 1;

                    //var _D = new Int8Array(_len);
                    var _D = new Uint8Array(_len);
                    for (var i=0; i< _len; i++){
                        _D[i] = _buf[5 + i];
                        //if(i<10) console.log('D =', _D[i]);
                    }

                    E_data = '';
                    for(var i=0; i<count; i++) {
                        var L = '';
                        L += 'a '; 
                        L += i * 1.0; 
                        L += ' ';
                        //var _v = (_D[2*i + 1] << 8) + (_D[2*i + 0]); //it.ch1.current.value
                        var _v  = _buf.readUInt16LE(5 + 2*i); //[38] Ch1 Raw          = 1253
                        _v = _v - 1000.0;
                        _v = _v / 10.0;
                        _v = _v * 1.0;
                        L += _v;
                        L += '\n';
                        E_data += L;
                    }
                    //var S = new Buffer( D ).toString('base64');
                    //it.ch1.record.data = S;




                    //this.tr4.disconnect();
                    this.Tr4Disconnect();
                    this.processCmd('proc_post', 'dummy Data');
                   // device.disconnect(); //just for testing
                }
            }
            else
            {
                // Not a 9e or 9f packet
                console.log('ERROR? Invalid (Not 0x9e or 0x9f) packet received. Bye....');
               // device.disconnect();
            }
            break;
            
        case 'proc_post':
            this.TT_4 = Date.now();
            //TODO tr4postit();
            this.TT_5 = Date.now();
            /*
            console.log('TT_0 =', this.TT_0)
            console.log('TT_1 =', this.TT_1)
            console.log('TT_2 =', this.TT_2)
            console.log('TT_3 =', this.TT_3)
            console.log('TT_4 =', this.TT_4)
            console.log('TT_5 =', this.TT_5)
            console.log('TT_5-0 =', this.TT_5 - this.TT_0)
            console.log('TT_5-1 =', this.TT_5 - this.TT_1)
            console.log('TT_4-1 =', this.TT_4 - this.TT_1)
            */

            var data = {};

            var e_data = '';
            for(var i=0; i<250; i++){
                var L = '';
                L += 'a '; 
                L += i * 1.0; 
                L += ' ';
                L += i * 3.0; 
                L += '\n';
                e_data += L;
            }

            e_data = E_data;

            //console.log('got ' + e_data);
            var lines = e_data.split('\n');
            for (var i = 0; i < lines.length - 1; i++) {
                var parts = lines[i].split(' ');
                var d = parts[0], x = parseFloat(parts[1]), y = parseFloat(parts[2]);
                if (!(d in data)) data[d] = [];
                data[d].push([x,y]);
            }
            var plots = [];
            for (var d in data) 
                plots.push( { data: data[d] } );
                //plots.push( { data: data[d].slice(data[d].length - 200) } );
            $.plot( $("#holder"),
                plots,
                { series:   { lines: { show: true, fill: true },  }//,
                  //yaxis:    { min: 0 },
                } 
            );
        break;

        default:
            break;
    }

}

var dl = new DL();
dl.id = ble_id;
//TODO pit.Pit_Load();  - can't get access to local file system from browser



/* ALICE
var pc2 = new RTCPeerConnection(cfg, con), dc2 = null, pc2icedone = false;

pc2.ondatachannel = function (e) {
  var datachannel = e.channel || e;
  dc2 = datachannel
  activedc = dc2
  dc2.onopen = function (e) { }
  dc2.onmessage = function (e) {
    if (e.data.size) {
      fileReceiver2.receive(e.data, {})
    } else {
      var data = JSON.parse(e.data)
      if (data.type === 'file') {
        fileReceiver2.receive(e.data, {})
      } else {
        chatlog.innerHTML += '[data.message.cmd] ' + data.message.cmd + '</p>';
        //chatlog.innerHTML += '[' + new Date() + '] ' + data.message.cmd + '</p>';
        chatlog.scrollTop = chatlog.scrollHeight;
      }
    }
  }
}

pc2.onicecandidate = function (e) {
  if (e.candidate == null) {
    localAnswer.value = JSON.stringify(pc2.localDescription);
  }
}
*/

</script>


</body>
</html>



<!--
<!DOCTYPE html>
<html>
<head>
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.1/jquery.min.js"></script>
<script src="jquery.flot.js"></script>
<script>
var iets = "";
window.onload = function() {
    var data = {};
 try {
  var s = new WebSocket("ws://localhost:8090/data");
 }
 catch (e) {
  var s = new MozWebSocket("ws://localhost:8090/data");
 }
    s.onopen = function() {
        console.log('Websocket Open');
        s.send('hi');
    };
    s.onmessage = function(e) {

      console.log('got ' + e.data);
      var lines = e.data.split('\n');
      for (var i = 0; i < lines.length - 1; i++) {
        var parts = lines[i].split(' ');
        var d = parts[0], x = parseFloat(parts[1]), y = parseFloat(parts[2]);
        if (!(d in data)) data[d] = [];
        data[d].push([x,y]);
      }
      var plots = [];
      for (var d in data) plots.push( { data: data[d].slice(data[d].length - 200) } );
      $.plot( $("#holder"), plots,
              {
                series: {
                  lines: { show: true, fill: true },
                },
                yaxis: { min: 0 },
              } );

      s.send('');
    };
};
</script>
</head>
<body>
<h3>LDR Plot</h3>
<div id="holder" style="width:800px;height:350px"></div>
</body>
</html>
-->
